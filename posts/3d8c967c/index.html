<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico"><link rel="icon" href="/img/favicon.ico"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="zy"><meta name="keywords" content="代码,技术,工具,生活,博客,随笔,分享"><meta name="description" content="节选了部分原论文内容，认真读一下这篇大名鼎鼎的transformer，旨在加深理解和学英语O(∩_∩)O"><meta property="og:type" content="article"><meta property="og:title" content="读《Transformer》"><meta property="og:url" content="https://zy946.github.io/posts/3d8c967c/index.html"><meta property="og:site_name" content="掐指不会算"><meta property="og:description" content="节选了部分原论文内容，认真读一下这篇大名鼎鼎的transformer，旨在加深理解和学英语O(∩_∩)O"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://bbs-img-cbc-cn.obs.cn-north-1.myhuaweicloud.com/data/attachment/forum/202101/01/215059a5naotj646bx1pel.png"><meta property="og:image" content="https://pic4.zhimg.com/v2-3423dd5e8ac178dd303f3e52b32b8d56_r.jpg"><meta property="article:published_time" content="2023-07-21T10:23:06.000Z"><meta property="article:modified_time" content="2024-06-18T11:39:09.666Z"><meta property="article:author" content="zy"><meta property="article:tag" content="nlp"><meta property="article:tag" content="深度学习"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://bbs-img-cbc-cn.obs.cn-north-1.myhuaweicloud.com/data/attachment/forum/202101/01/215059a5naotj646bx1pel.png"><meta name="referrer" content="no-referrer-when-downgrade"><title>读《Transformer》 - 掐指不会算</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"zy946.github.io",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:50,cursorChar:"|",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 7.2.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>掐指不会算</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item"><a class="nav-link" href="/tool/" target="_self"><i class="iconfont icon-mini-program-fill"></i> <span>工具</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="读《Transformer》"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-07-21 18:23" pubdate>2023年7月21日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 3k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 26 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">读《Transformer》</h1><div class="markdown-body"><blockquote><p>节选了部分原论文内容，认真读一下这篇大名鼎鼎的transformer，旨在加深理解和学英语O(∩_∩)O</p></blockquote><span id="more"></span><h1 id="Attention-Is-All-You-Need"><a href="#Attention-Is-All-You-Need" class="headerlink" title="Attention Is All You Need"></a>Attention Is All You Need</h1><p>有点霸气</p><h2 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h2><blockquote><p>The dominant sequence transduction models are based on complex recurrent or convolutional neural networks that include an encoder and a decoder.</p></blockquote><p>主流的序列转换模型都是基于包含编码器和解码器的循环或卷积神经网络。</p><blockquote><p>The best performing models also connect the encoder and decoder through an attention mechanism.</p></blockquote><p>表现最好的模型也是通过注意力机制连接编码器和解码器。</p><blockquote><p>We propose a new simple network architecture, the Transformer, based solely on attention mechanisms, dispensing with recurrence and convolutions entirely.</p></blockquote><p>我们提出了一种新型简单的网络架构，Transformer，只基于注意力机制，完全不需要循环和卷积。</p><blockquote><p>Experiments on two machine translation tasks show these models to be superior in quality while being more parallelizable and requiring significantly less time to train.</p></blockquote><p>在两个机器翻译任务的实验上表现出这些模型具有更好的质量，同时具有更强的并行性，训练时间明显减少。</p><blockquote><p>Our model achieves 28.4 BLEU on the WMT 2014 English-to-German translation task, improving over the existing best results, including ensembles, by over 2 BLEU. On the WMT 2014 English-to-French translation task, our model establishes a new single-model state-of-the-art BLEU score of 41.8 after training for 3.5 days on eight GPUs, a small fraction of the training costs of the best models from the literature.</p></blockquote><p>我们的模型在WMT2014英转德翻译任务上实现了28.4 BLEU，比目前全部最好的结果提高了2 BLEU。在WMT2014英转法翻译任务上，我们的模型在 8个GPU训练了3天半（文献中最好模型训练成本的一小部分）后以41.8刷新了单模型最高的BLUE成绩。</p><blockquote><p>We show that the Transformer generalizes well to other tasks by applying it successfully to English constituency parsing both with large and limited training data.</p></blockquote><p>把它成功用在大量和有限的训练数据的英语语句成分分析表明了Transformer在其他任务上具有不错的泛化性。</p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1.Introduction"></a>1.Introduction</h2><blockquote><p>Recurrent neural networks, long short-term memory and gated recurrent neural networks in particular, have been firmly established as state of the art approaches in sequence modeling and transduction problems such as language modeling and machine translation. Numerous efforts have since continued to push the boundaries of recurrent language models and encoder-decoder architectures.</p></blockquote><p>RNN，特别是LSTM和门控RNN，已经在像语言模型化和机器翻译这样的序列模型化和转换问题被坚定地确立为最先进的方法。此后许多努力继续推动循环语言模型和编解码架构的边界。</p><blockquote><p>Recurrent models typically factor computation along the symbol positions of the input and output sequences. Aligning the positions to steps in computation time, they generate a sequence of hidden states <code>$h_t$</code> , as a function of the previous hidden state <code>$h_&#123;t-1&#125;$</code> and the input for position <code>$t$</code> .</p></blockquote><p>循环模型通常考虑沿着输入和输出序列的符号位置计算。把位置和计算时间的步数对齐，他们产生一个隐藏状态序列 <code>$h_t$</code> ，作为先前的隐藏状态 <code>$h_&#123;t-1&#125;$</code> 和位置 <code>$t$</code> 输入的函数。</p><blockquote><p>This inherently sequential nature precludes parallelization within training examples, which becomes critical at longer sequence lengths, as memory constraints limit batching across examples.Recent work has achieved significant improvements in computational efficiency through factorization tricks and conditional computation, while also improving model performance in case of the latter. The fundamental constraint of sequential computation, however, remains.</p></blockquote><p>这种固有的顺序性排除了在训练样本时并行化，对于较长的序列变得严重因为内存约束限制样本批处理。最近的工作通过分解技巧和条件计算已经显著改善了计算效率，同时后者也提高了模型性能。然而序列计算的基本限制仍然存在。</p><blockquote><p>Attention mechanisms have become an integral part of compelling sequence modeling and transduction models in various tasks, allowing modeling of dependencies without regard to their distance in the input or output sequences. In all but a few cases, however, such attention mechanisms are used in conjunction with a recurrent network.</p></blockquote><p>注意力机制已经成为在许多任务中引人注目的序列模型和转换模型不可或缺的一部分，允许对依赖关系进行建模，而不考虑它们在输入或输出序列中的距离。然而除了少数外，这种注意力机制被用在与循环网络结合。</p><blockquote><p>In this work we propose the Transformer, a model architecture eschewing recurrence and instead relying entirely on an attention mechanism to draw global dependencies between input and output. The Transformer allows for significantly more parallelization and can reach a new state of the art in translation quality after being trained for as little as twelve hours on eight P100 GPUs.</p></blockquote><p>这次我们提出了Transformer，一种避免循环也不完全依赖注意力机制来描述输入输出间的全局依赖关系的模型架构。Transformer明显允许更强的并行化并且能够在8个P100 GPU上被训练仅12个小时后达到翻译质量的一个新境界。</p><h2 id="2-Background"><a href="#2-Background" class="headerlink" title="2.Background"></a>2.Background</h2><blockquote><p>The goal of reducing sequential computation also forms the foundation of the Extended Neural GPU, ByteNet and ConvS2S, all of which use convolutional neural networks as basic building block, computing hidden representations in parallel for all input and output positions. In these models, the number of operations required to relate signals from two arbitrary input or output positions grows in the distance between positions, linearly for ConvS2S and logarithmically for ByteNet. This makes it more difficult to learn dependencies between distant positions. In the Transformer this is reduced to a constant number of operations, albeit at the cost of reduced effective resolution due to averaging attention-weighted positions, an effect we counteract with Multi-Head Attention as described in section 3.2.</p></blockquote><p>减少顺序计算的目标也形成了Extended Neural GPU，ByteNet和ConvS2S的基础，他们都使用卷积神经网络作为基础构建块，对所有的输入输出位置并行计算隐藏层。在这些模型中，将任意两个输入或输出位置信号关联起来的参数随着两个位置的距离增长，ConS2S是线性的，ByteNet是对数的。这使得远距离位置的依赖关系难以学习。在Transformer中尽管由于平均注意力加权位置减少有效分辨率为代价，这被简化成一个常量，我们用在3.2节描述的多头注意力来抵消这个效果。</p><blockquote><p>Self-attention, sometimes called intra-attention is an attention mechanism relating different positions of a single sequence in order to compute a representation of the sequence. Self-attention has been used successfully in a variety of tasks including reading comprehension, abstractive summarization, textual entailment and learning task-independent sentence representations.</p></blockquote><p>自注意力，有时被称为内注意力，是一种关于一个信号序列的不同位置的注意力机制，为了计算这个序列的表征。自注意力已经被成功地用在各种各样的任务中包括阅读理解，抽象概括，文本语义和依赖于语句特征的学习任务。</p><blockquote><p>End-to-end memory networks are based on a recurrent attention mechanism instead of sequence aligned recurrence and have been shown to perform well on simple-language question answering and language modeling tasks.</p></blockquote><p>端到端记忆网络基于循环注意力机制而不是序列对齐的循环并且已被证明在简单语言问答和语言建模任务上表现很好。</p><blockquote><p>To the best of our knowledge, however, the Transformer is the first transduction model relying entirely on self-attention to compute representations of its input and output without using sequence-aligned RNNs or convolution.</p></blockquote><p>然而，据我们所知，Transformer是第一个没有使用序列对齐的RNN或者卷积完全依赖自注意力来计算输入输出的特征的转换模型。</p><h2 id="3-Model-Architecture"><a href="#3-Model-Architecture" class="headerlink" title="3.Model Architecture"></a>3.Model Architecture</h2><blockquote><p>Most competitive neural sequence transduction models have an encoder-decoder structure. Here, the encoder maps an input sequence of symbol representations (<code>$x_1,...,x_n$</code>) to a sequence of continuous representations <code>$z=(z_1,...,z_n)$</code> Given <code>$z$</code> , the decoder then generates an output sequence <code>$(y_1,...,y_m)$</code> of symbols one element at a time. At each step the model is auto-regressive, consuming the previously generated symbols as additional input when generating the next.</p></blockquote><p>大多具有竞争力的神经序列转换模型用编解码的架构。这里，编码器映射由(<code>$x_1,...,x_n$</code>)表示的输入序列到由 <code>$z=(z_1,...,z_n)$</code> 表示的连续序列，然后解码器一次生成一个由<code>$(y_1,...,y_m)$</code>表示的输出序列中的一个元素。每一步模型是自动回归的，当生成下一个时用先前生成的特征作为加性输入。</p><blockquote><p>The Transformer follows this overall architecture using stacked self-attention and point-wise, fully connected layers for both the encoder and decoder, shown in the left and right halves of Figure 1, respectively.</p></blockquote><p>Transformer遵循使用自注意力堆叠和整体架构和逐点全连接层的编码器和解码器的整体架构，分别展示在Figue 1的左右两部分。</p><p><img src="https://bbs-img-cbc-cn.obs.cn-north-1.myhuaweicloud.com/data/attachment/forum/202101/01/215059a5naotj646bx1pel.png" srcset="/img/loading.gif" lazyload alt="Figure1"></p><h3 id="3-1Encoder-and-Decoder-Stacks"><a href="#3-1Encoder-and-Decoder-Stacks" class="headerlink" title="3.1Encoder and Decoder Stacks"></a>3.1Encoder and Decoder Stacks</h3><blockquote><p><strong>Encoder</strong>: The encoder is composed of a stack of <code>$N = 6$</code> identical layers. Each layer has two sub-layers. The first is a multi-head self-attention mechanism, and the second is a simple, position-wise fully connected feed-forward network. We employ a residual connection around each of the two sub-layers, followed by layer normalization. That is, the output of each sub-layer is <code>$LayerNorm(x + Sublayer(x))$</code> , where <code>$Sublayer(x)$</code> is the function implemented by the sub-layer itself. To facilitate these residual connections, all sub-layers in the model, as well as the embedding layers, produce outputs of dimension <code>$d_&#123;model&#125; = 512$</code> .</p></blockquote><p><strong>编码器</strong>：编码器由<code>$N = 6$</code>完全一样的层的栈构成的。每一层有两个子层。第一层是多头自注意力机制，第二层是一个简单的按位置全连接的前馈网络。我们在两个子层的每一层周围用了残差连接，接着层归一化。也就是说，每一个子层的输出是<code>$LayerNorm(x + Sublayer(x))$</code>，这里的<code>$Sublayer(x)$</code>是子层本身实现的函数。为了方便这些残差连接，所有模型的子层还有嵌入层的输出维度是<code>$d_&#123;model&#125; = 512$</code>。</p><blockquote><p><strong>Decoder</strong>: The decoder is also composed of a stack of <code>$N = 6$</code> identical layers. In addition to the two sub-layers in each encoder layer, the decoder inserts a third sub-layer, which performs multi-head attention over the output of the encoder stack. Similar to the encoder, we employ residual connections around each of the sub-layers, followed by layer normalization. We also modify the self-attention sub-layer in the decoder stack to prevent positions from attending to subsequent positions. This masking, combined with fact that the output embeddings are offset by one position, ensures that the predictions for position <code>$i$</code> can depend only on the known outputs at positions less than <code>$i$</code>.</p></blockquote><p><strong>解码器</strong>：解码器也是由<code>$N = 6$</code>完全一样的层的栈构成的。除了在每个编码器层的两个子层，解码器插入了第三个子层，他对编码器栈的输出做多头注意力。跟编码器相似，我们也在每个子层周围用残差连接，接着层归一化。我们也修改了解码器栈的自注意子层来防止位置关注到后续位置。这样掩蔽(Mask)，与输出嵌入被一个位置偏移结合，确保对位置<code>$i$</code>的预测只能依赖位置小于<code>$i$</code>的已知输出。</p><h3 id="3-2-Attention"><a href="#3-2-Attention" class="headerlink" title="3.2 Attention"></a>3.2 Attention</h3><blockquote><p>An attention function can be described as mapping a query and a set of key-value pairs to an output, where the query, keys, values, and output are all vectors. The output is computed as a weighted sum of the values, where the weight assigned to each value is computed by a compatibility function of the query with the corresponding key.</p></blockquote><p>注意力函数可以被描述成映射一个查询(<code>$Q$</code>)和一组键值对(<code>$K:V$</code>)到一个输出，这里的<code>$Q$</code>,<code>$K$</code>,<code>$V$</code>都是向量。输出是<code>$V$</code>加权求和计算得到的，分配给每个<code>$V$</code>的权重是由查询<code>$Q$</code>和相应的键<code>$K$</code>的一个相似性函数计算得到的。</p><p><img src="https://pic4.zhimg.com/v2-3423dd5e8ac178dd303f3e52b32b8d56_r.jpg" srcset="/img/loading.gif" lazyload alt="Figure 2"></p><h4 id="3-2-1-Scaled-Dot-Product-Attention"><a href="#3-2-1-Scaled-Dot-Product-Attention" class="headerlink" title="3.2.1 Scaled Dot-Product Attention"></a>3.2.1 Scaled Dot-Product Attention</h4><blockquote><p>We call our particular attention “Scaled Dot-Product Attention” (Figure 2). The input consists of queries and keys of dimension <code>$d_k$</code> , and values of dimension <code>$d_v$</code> . We compute the dot products of the query with all keys, divide each by <code>$\sqrt&#123;d_k&#125;$</code> , and apply a softmax function to obtain the weights on the values.</p></blockquote><p>我们把我们特别的注意力称为“缩放的点积注意力”（图2）。输入是由 <code>$q$</code>和<code>$d_k$</code> 维的<code>$k$</code>以及<code>$d_v$</code>的<code>$v$</code>构成的。我们计算<code>$q$</code>和所有<code>$k$</code>的点积，每一个除以<code>$\sqrt&#123;d_k&#125;$</code>，然后用一个softmax函数来获得不同<code>$v$</code>的权重。</p><blockquote><p>In practice, we compute the attention function on a set of queries simultaneously, packed together into a matrix $Q$ . The keys and values are also packed together into matrices <code>$K$</code> and <code>$V$</code> . We compute the matrix of outputs as:</p></blockquote><p>实际上，我们是把一组<code>$q$</code>打包成一个矩阵<code>$Q$</code>同时计算注意力函数。<code>$k$</code>和<code>$v$</code>也是一起被打包进矩阵<code>$K$</code>和<code>$V$</code>。我们计算输出矩阵如下：</p><p>$$<br>Attention(Q,K,V)&#x3D;softmax(\frac{QK^T}{\sqrt{d_k}}V)<br>$$</p><blockquote><p>The two most commonly used attention functions are additive attention, and dot-product (multi-plicative) attention. Dot-product attention is identical to our algorithm, except for the scaling factor of <code>$\frac&#123;1&#125;&#123;\sqrt&#123;d_k&#125;&#125;$</code>. Additive attention computes the compatibility function using a feed-forward network with a single hidden layer. While the two are similar in theoretical complexity, dot-product attention is much faster and more space-efficient in practice, since it can be implemented using highly optimized matrix multiplication code.</p></blockquote><p>两种最常用的注意力函数是加性注意力和乘性(点积)注意力。点积的注意力和我们的算法除了 <code>$\frac&#123;1&#125;&#123; \sqrt&#123;d_k&#125; &#125;$</code> 这个缩放因子是一样的。加性注意力用一个单一隐藏层的前馈网络计算相似函数。虽然这两种算法在理论上的复杂性是相似的，但是实践中点积注意力更快，更省空间，因为他可以用高度优化的矩阵乘法代码实现。</p><blockquote><p>While for small values of <code>$d_k$</code> the two mechanisms perform similarly, additive attention outperforms dot product attention without scaling for larger values of <code>$d_k$</code>. We suspect that for large values of <code>$d_k$</code> , the dot products grow large in magnitude, pushing the softmax function into regions where it has extremely small gradients. To counteract this effect, we scale the dot products by <code>$\frac&#123;1&#125;&#123;\sqrt&#123;d_k&#125;&#125;$</code> .</p></blockquote><p>然而对于小的<code>$d_k$</code>两种机制表现差不多，对于更大的<code>$d_k$</code>加性注意力优于不带缩放的点积注意力。我们猜想对于大的<code>$d_k$</code>点积变的很大，使softmax进入梯度非常小的区域。为了抵消这种效应，我们把点积缩小了 <code>$\frac&#123;1&#125;&#123;\sqrt&#123;d_k&#125;&#125;$</code> 。</p><h4 id="3-2-2-Multi-Head-Attention"><a href="#3-2-2-Multi-Head-Attention" class="headerlink" title="3.2.2 Multi-Head Attention"></a>3.2.2 Multi-Head Attention</h4><blockquote><p>Instead of performing a single attention function with <code>$d_&#123;model&#125;$</code>-dimensional keys, values and queries, we found it beneficial to linearly project the queries, keys and values <code>$h$</code> times with different, learned linear projections to <code>$d_k$</code> , <code>$d_k$</code> and <code>$d_v$</code> dimensions, respectively. On each of these projected versions of queries, keys and values we then perform the attention function in parallel, yielding <code>$d_v$</code> -dimensional output values. These are concatenated and once again projected, resulting in the final values.</p></blockquote><p>与用<code>$d_&#123;model&#125;$</code>维的<code>$k,v和q$</code>执行单一注意力函数不同，我们发现用分别到<code>$d_k$</code> , <code>$d_k$</code> 和 <code>$d_v$</code>不同的学习到的线性映射对线性映射<code>$q,k,v$</code>h次是有益的(结合图片看）。对这些<code>$q,k,v$</code>的每一个投影版我们接着并行地执行注意力函数，生成一些<code>$d_v$</code>维的输出。把这些输出连接起来再次映射生成最终的结果。</p><blockquote><p>Multi-head attention allows the model to jointly attend to information from different representation subspaces at different positions. With a single attention head, averaging inhibits this.</p></blockquote><p>多头注意力让模型共同关注来自不同的在不同位置的子空间特征。用一个注意力头平均抑制了这一点。</p><p>$$<br>MultiHead(Q,K,V) &#x3D; Concat(head_1 ,…,head_h )W^O<br>$$<br>$$<br>where\ head_i &#x3D; Attention(QW_i^Q,KW_i^K,VW^V_i)<br>$$</p><blockquote><p>Where the projections are parameter matrices <code>$W_i^Q\in R^&#123;d_&#123;model&#125;\times d_k&#125;$</code> , <code>$W_i^K \in R^&#123;d_&#123;model&#125; \times d_k&#125;$</code> , <code>$W_i^V \in R^&#123;d_&#123;model&#125; \times d_v&#125;$</code>and <code>$W^O \in R^&#123;hd_v \times d_&#123;model&#125;&#125;$</code> .</p></blockquote><blockquote><p>In this work we employ <code>$h = 8$</code> parallel attention layers, or heads. For each of these we use <code>$d_k = d_v = d_&#123;model&#125;/h = 64$</code> . Due to the reduced dimension of each head, the total computational cost is similar to that of single-head attention with full dimensionality.</p></blockquote><p>在这次工作中我们采用了 <code>$h=8$</code> 并行注意力层（头）。对这些中的每一个我们用 <code>$d_k = d_v = d_&#123;model&#125;/h = 64$</code> 。由于减小了每个头的维度，总计算量和单头全维度的注意力相近。</p><h4 id="3-2-3-Applications-of-Attention-in-our-Model"><a href="#3-2-3-Applications-of-Attention-in-our-Model" class="headerlink" title="3.2.3 Applications of Attention in our Model"></a>3.2.3 Applications of Attention in our Model</h4><blockquote><p>The Transformer uses multi-head attention in three different ways:</p></blockquote><p>Transformer 以三种不同的方式使用多头注意力。</p><blockquote><ul><li>In “encoder-decoder attention” layers, the queries come from the previous decoder layer, and the memory keys and values come from the output of the encoder. This allows every position in the decoder to attend over all positions in the input sequence. This mimics the typical encoder-decoder attention mechanisms in sequence-to-sequence models.</li></ul></blockquote><ul><li>在”encoder-decoder attention”层，查询值来自先前的解码层，存储的键值对来自编码器的输出。这让解码器的每个位置关注输入序列的全部位置。这模仿了在 sequence-to-sequence模型中典型的编解码注意力机制。</li></ul><blockquote><ul><li>The encoder contains self-attention layers. In a self-attention layer all of the keys, values and queries come from the same place, in this case, the output of the previous layer in the encoder. Each position in the encoder can attend to all positions in the previous layer of the encoder.</li></ul></blockquote><ul><li>编码器包含自注意力层。在自注意力层中所有的键值和查询在这种情况下都来自相同的地方——编码器的前层的输出。</li></ul><blockquote><ul><li>Similarly, self-attention layers in the decoder allow each position in the decoder to attend to all positions in the decoder up to and including that position. We need to prevent leftward information flow in the decoder to preserve the auto-regressive property. We implement this inside of scaled dot-product attention by masking out (setting to −∞ ) all values in the input of the softmax which correspond to illegal connections. See Figure 2.</li></ul></blockquote><ul><li>类似的，在解码器的自注意力层让解码器的每个位置关注到解码器的所有位置包括那个位置。我们需要阻止左边的信息流入到解码器来维持自回归的特性。我们通过遮盖（设置为-∞）对应不合理连接的softmax输入的所有值，在缩放点积注意力中实现这一点。</li></ul><h3 id="3-3-Position-wise-Feed-Forward-Networks"><a href="#3-3-Position-wise-Feed-Forward-Networks" class="headerlink" title="3.3 Position-wise Feed-Forward Networks"></a>3.3 Position-wise Feed-Forward Networks</h3><blockquote><p>In addition to attention sub-layers, each of the layers in our encoder and decoder contains a fully connected feed-forward network, which is applied to each position separately and identically. This consists of two linear transformations with a ReLU activation in between.<br>$$<br>FFN(x) &#x3D; max(0,xW_1 + b_1)W_2 + b_2<br>$$<br>While the linear transformations are the same across different positions, they use different parameters from layer to layer. Another way of describing this is as two convolutions with kernel size 1. The dimensionality of input and output is <code>$d_&#123;model&#125; = 512$</code>, and the inner-layer has dimensionality<br><code>$d_&#123;ff&#125;$</code> &#x3D; 2048.</p></blockquote><h3 id="3-4-Embeddings-and-Softmax"><a href="#3-4-Embeddings-and-Softmax" class="headerlink" title="3.4 Embeddings and Softmax"></a>3.4 Embeddings and Softmax</h3><blockquote><p>Similarly to other sequence transduction models, we use learned embeddings to convert the input tokens and output tokens to vectors of dimension <code>$d_&#123;model&#125;$</code> . We also use the usual learned linear transfor-mation and softmax function to convert the decoder output to predicted next-token probabilities. In our model, we share the same weight matrix between the two embedding layers and the pre-softmax linear transformation, similar to [ 30 ]. In the embedding layers, we multiply those weights by <code>$\sqrt&#123;d_&#123;model&#125;&#125;$</code> model .</p></blockquote><h3 id="3-5-Positional-Encoding"><a href="#3-5-Positional-Encoding" class="headerlink" title="3.5 Positional Encoding"></a>3.5 Positional Encoding</h3><blockquote><p>Since our model contains no recurrence and no convolution, in order for the model to make use of the order of the sequence, we must inject some information about the relative or absolute position of the tokens in the sequence. To this end, we add “positional encodings” to the input embeddings at the bottoms of the encoder and decoder stacks. The positional encodings have the same dimension d model as the embeddings, so that the two can be summed. There are many choices of positional encodings, learned and fixed.</p></blockquote><blockquote><p>In this work, we use sine and cosine functions of different frequencies:<br>$$<br>PE(pos,2i) &#x3D; sin(pos&#x2F;10000^{2i&#x2F;d_{model}})<br>$$<br>$$<br>PE(pos,2i+1) &#x3D; cos(pos&#x2F;10000^{2i&#x2F;d_{model}})<br>$$<br>where <code>$pos$</code> is the position and <code>$i$</code> is the dimension. That is, each dimension of the positional encoding corresponds to a sinusoid. The wavelengths form a geometric progression from 2π to 10000·2π . We chose this function because we hypothesized it would allow the model to easily learn to attend by relative positions, since for any fixed offset <code>$k$</code>, <code>$PE_&#123;pos&#125;+k$</code> can be represented as a linear function of <code>$PE_&#123;pos&#125;$</code> .</p></blockquote><blockquote><p>We also experimented with using learned positional embeddings instead, and found that the two versions produced nearly identical results (see Table 3 row (E)). We chose the sinusoidal version because it may allow the model to extrapolate to sequence lengths longer than the ones encountered during training.</p></blockquote></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E8%AE%BA%E6%96%87/" class="category-chain-item">论文</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/nlp/" class="print-no-link">#nlp</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" class="print-no-link">#深度学习</a></div></div><div class="license-box my-3"><div class="license-title"><div>读《Transformer》</div><div>https://zy946.github.io/posts/3d8c967c/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>zy</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2023年7月21日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/posts/fdd48e00/" title="TFT_espi图片转换脚本"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">TFT_espi图片转换脚本</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/posts/1cd5914f/" title="免费部署ChatGPT4等国内可访问网站"><span class="hidden-mobile">免费部署ChatGPT4等国内可访问网站</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js",(function(){mermaid.initialize({theme:"default"}),Fluid.utils.listenDOMLoaded((function(){Fluid.events.registerRefreshCallback((function(){"mermaid"in window&&mermaid.init()}))}))}))</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><span>ZY</span> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>hexo-theme-fluid</span></a></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script>window.MathJax?(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset(),MathJax.typesetPromise()):window.MathJax={tex:{inlineMath:{"[+]":[["$","$"]]}},loader:{load:["ui/lazy"]},options:{renderActions:{insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(t=>{let e=t.parentNode;"li"===e.nodeName.toLowerCase()&&e.parentNode.classList.add("has-jax")})},"",!1]}}},Fluid.events.registerRefreshCallback((function(){"MathJax"in window&&MathJax.startup.document&&"function"==typeof MathJax.startup.document.state&&(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset(),MathJax.typesetPromise())}))</script><script src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js"></script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>